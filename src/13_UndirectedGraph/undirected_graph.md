# Undirected graph

由顶点和边组成的形式。

## graph中的基本问题

![1731740230099](image/undirected_graph/1731740230099.png)

## Graph的表示

* 用list存储所有的边
* 用邻接矩阵存储，维护一个VxV的二维数组
* 用邻接list存储，list中第i个节点存储与i链接的其他vertex组成的链表

![1731741647030](image/undirected_graph/1731741647030.png)

## DFS

深度优先遍历，模拟迷宫探索，可用于查找conneced component和两点之间是否有path链接，实现方式：

* 将当前访问节点设为visited（有一个数组存储节点是否被查找）
* 递归的查询当前节点的临近节点，当所有邻近节点都被访问后，返回到上一节点
* 所有节点都被访问后，遍历结束

![1731748350972](image/undirected_graph/1731748350972.png)

## BFS

广度优先搜索，用队列实现，用于寻找不带权重的最短路径；

![1731826406016](image/undirected_graph/1731826406016.png)

>
> DFS（深度优先搜索）和 BFS（广度优先搜索）各有特点和适用场景：
>
> ### DFS（深度优先搜索）
>
> #### 特点
>
> - **递归或栈实现**。
> - **深入优先**：沿一条路径走到底，再回溯。
> - **内存占用小**：对于稀疏图较为高效。
>
> #### 适用场景
>
> - **路径问题**：如寻找任意一条路径。
> - **拓扑排序**。
> - **连通分量**：如判断图的连通性。
> - **迷宫问题**：探索所有可能路径。
>
> ### BFS（广度优先搜索）
>
> #### 特点
>
> - **队列实现**。
> - **层次遍历**：逐层扩展节点。
> - **最短路径**：在未加权图中找到最短路径。
>
> #### 适用场景
>
> - **最短路径问题**：如无权图的最短路径。
> - **广度优先遍历**：如社交网络中寻找某种关系。
> - **连通性检查**：如判断两个节点是否连通。
>
> 选择使用 DFS 或 BFS 取决于具体问题的需求。
>
>
> DFS 和 BFS 都可以用于路径查找，但在某些方面有所不同：
>
> ### 区别
>
> 1. **路径性质**：
>
>    - **BFS**：在无权图中，BFS 找到的是最短路径，因为它按层次遍历。
>    - **DFS**：可能找到的不是最短路径，深入探索后才回溯。
> 2. **内存使用**：
>
>    - **BFS**：需要存储每一层的节点，内存消耗可能较大。
>    - **DFS**：使用递归或栈，内存消耗通常较小。
>
> ### 特定场景
>
> 1. **循环检测**：
>
>    - **DFS**：可以很方便地检测图中的环。
> 2. **拓扑排序**：
>
>    - **DFS**：适用于有向无环图（DAG）的拓扑排序。
> 3. **迷宫或复杂路径探索**：
>
>    - **DFS**：可以用于探索所有可能路径，适合需要完整搜索的场景。
> 4. **最短路径**：
>
>    - **BFS**：在无权图中最适合用于寻找最短路径。
>
> ### 适用性
>
> - **DFS 能做而 BFS 不能**：
>
>   - 有些需要完整搜索、递归性质的问题更适合 DFS。
> - **BFS 能做而 DFS 不能**：
>
>   - 找到无权图的最短路径问题时，BFS 更为高效。
>
> 选择使用哪个算法取决于问题的具体需求和图的性质。
